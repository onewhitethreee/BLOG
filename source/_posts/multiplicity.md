---
uuid: a8d65b70-e28a-11f0-a5b5-39118c5f9ca1
title: multiplicity
date: 2025-12-26 19:42:41
tags:
hide: true
---

好的！这是**多重性（Multiplicidad）**的概念，表示**关系的数量**！

---

## 🎯 多重性：表示"有多少个"

**写在关联线的两端，表示数量关系**

---

## 📊 常见的多重性符号

| 符号 | 含义 | 例子 |
|------|------|------|
| `1` | 正好1个 | 一个人有1个身份证 |
| `0..1` | 0个或1个 | 一个人有0或1个配偶 |
| `*` 或 `0..*` | 0个或多个 | 一个人有0个或多个孩子 |
| `1..*` | 1个或多个 | 一个公司至少有1个员工 |
| `n` | 固定n个 | 一辆车有4个轮子 |
| `n..m` | n到m个 | 一个班级有20-40个学生 |

---

## 🍳 做饭系统例子

### **1. 一对一 (1 to 1)**
```
┌─────────┐         1        1  ┌─────────┐
│  厨师    │──────────────────────│ 厨师帽   │
└─────────┘                      └─────────┘
```
**含义：** 一个厨师有一顶厨师帽，一顶帽子只属于一个厨师

**代码：**
```java
class 厨师 {
    private 厨师帽 hat;  // 只有1个
}

class 厨师帽 {
    private 厨师 owner;  // 只属于1个厨师
}
```

---

### **2. 一对多 (1 to many)**
```
┌─────────┐         1       0..* ┌─────────┐
│  厨房    │──────────────────────│  厨师    │
└─────────┘                      └─────────┘
```
**含义：** 一个厨房可以有0个或多个厨师

**代码：**
```java
class 厨房 {
    private List<厨师> chefs;  // 多个厨师
}

class 厨师 {
    private 厨房 kitchen;  // 只在1个厨房工作
}
```

---

### **3. 多对多 (many to many)**
```
┌─────────┐        0..*    0..*  ┌─────────┐
│  厨师    │──────────────────────│  菜谱    │
└─────────┘                      └─────────┘
```
**含义：** 一个厨师会做多道菜，一道菜也可以被多个厨师会做

**代码：**
```java
class 厨师 {
    private List<菜谱> recipes;  // 会做多道菜
}

class 菜谱 {
    private List<厨师> chefs;  // 可以被多个厨师会做
}
```

---

## 🎨 完整餐厅系统多重性示例

```
        餐厅系统
        
┌─────────┐        1      1..* ┌─────────┐
│  餐厅    │◆────────────────────│  厨房    │
└─────────┘                     └─────────┘
    │                               │
    │ 1                             │ 1
    │                               │
    │                               │ 1..*
    │                               ↓
    │                           ┌─────────┐
    │                           │  厨师    │
    │                           └─────────┘
    │                               │
    │ 0..*                          │ 1
    ↓                               ↓
┌─────────┐        0..*    1   ┌─────────┐
│  顾客    │────────────────────│  订单    │
└─────────┘                    └─────────┘
    │                               │
    │                               │ 1
    │                               │
    │                               │ 1..*
    │                               ↓
    │                           ┌─────────┐
    │                           │  菜品    │
    │                           └─────────┘
    │                               │
    │                               │ 0..*
    │                               │
    │ 0..1                          │ 0..*
    ↓                               ↓
┌─────────┐                    ┌─────────┐
│ VIP卡    │                    │  食材    │
└─────────┘                    └─────────┘
```

---

## 📖 详细解读每个关系

### **1. 餐厅 ◆────1────1..*──── 厨房**
```
一个餐厅有1个或多个厨房（至少要有1个）
```
**代码：**
```java
class 餐厅 {
    private List<厨房> kitchens;  // 至少1个
    
    public 餐厅() {
        kitchens = new ArrayList<>();
        kitchens.add(new 厨房());  // 至少添加1个
    }
}
```

---

### **2. 厨房 ────1────1..*──── 厨师**
```
一个厨房至少有1个厨师（不然谁做菜？）
一个厨师只在1个厨房工作
```
**代码：**
```java
class 厨房 {
    private List<厨师> chefs;  // 至少1个
    
    void 雇佣厨师(厨师 chef) {
        if (chefs.isEmpty()) {
            chefs.add(chef);  // 必须至少1个
        }
    }
}

class 厨师 {
    private 厨房 workplace;  // 只有1个
}
```

---

### **3. 顾客 ────0..*────1──── 订单**
```
一个顾客可以有0个或多个订单
一个订单只属于1个顾客
```
**代码：**
```java
class 顾客 {
    private List<订单> orders = new ArrayList<>();  // 可以是空的
}

class 订单 {
    private 顾客 customer;  // 必须有1个顾客
}
```

---

### **4. 订单 ────1────1..*──── 菜品**
```
一个订单至少有1道菜（不然点啥？）
一道菜可以在多个订单里
```
**代码：**
```java
class 订单 {
    private List<菜品> dishes;  // 至少1道菜
    
    void 添加菜品(菜品 dish) {
        dishes.add(dish);
    }
    
    boolean 可以提交() {
        return !dishes.isEmpty();  // 必须有菜
    }
}
```

---

### **5. 顾客 ────0..1────1──── VIP卡**
```
一个顾客可以有0个或1张VIP卡（最多1张）
一张VIP卡只属于1个顾客
```
**代码：**
```java
class 顾客 {
    private VIP卡 vipCard;  // 可以是null，最多1个
    
    void 办理VIP() {
        if (vipCard == null) {
            vipCard = new VIP卡();
        } else {
            System.out.println("已经有VIP卡了！");
        }
    }
}
```

---

### **6. 菜品 ────0..*────0..*──── 食材**
```
一道菜可以有0个或多个食材
一种食材可以用在0道或多道菜里
```
**代码：**
```java
class 菜品 {
    private List<食材> ingredients = new ArrayList<>();
}

class 食材 {
    private List<菜品> usedInDishes = new ArrayList<>();
}
```

---

## 🎯 如何判断多重性？

### **问自己这些问题：**

#### **从A到B的方向：**

| 问题 | 多重性 | 例子 |
|------|--------|------|
| B必须存在吗？ | 不是0开头 | `1`, `1..*` |
| B可以没有吗？ | 是0开头 | `0..1`, `0..*` |
| B最多1个吗？ | ..1结尾 | `0..1`, `1` |
| B可以很多个吗？ | ..*结尾 | `0..*`, `1..*` |
| B有固定数量吗？ | 具体数字 | `4`, `2..5` |

---

## 🔍 实战练习

### **判断多重性：**

```
1. 一个人 ？ 一个身份证
2. 一辆车 ？ 轮子
3. 一个学生 ？ 课程
4. 一个老师 ？ 学生
5. 一个人 ？ 父母
6. 一个人 ？ 孩子
```

**答案：**
```
1. 人 ──1────1── 身份证
   (一个人只有1个身份证，一个身份证只属于1个人)

2. 车 ──1────4── 轮子
   (一辆车正好4个轮子)

3. 学生 ──0..*────0..*── 课程
   (一个学生选0到多门课，一门课有0到多个学生)

4. 老师 ──1────0..*── 学生
   (一个老师教0到多个学生，一个学生有1个班主任)

5. 人 ──1────2── 父母
   (一个人有2个父母)

6. 人 ──1────0..*── 孩子
   (一个人有0到多个孩子，孩子有1个母亲)
```

---

## 💡 记忆技巧

### **看箭头两端：**

```
    A ────m────n──── B
         ↑      ↑
         │      └─ B对于A来说有几个
         └─ A对于B来说有几个
```

### **常见模式：**

| 关系类型 | 多重性 | 生活例子 |
|---------|--------|----------|
| **一对一** | `1 ─── 1` | 人-身份证 |
| **一对多** | `1 ─── 0..*` | 妈妈-孩子 |
| **多对多** | `0..* ─── 0..*` | 学生-课程 |
| **必须有** | `1 ─── 1..*` | 公司-员工 |
| **可选的** | `1 ─── 0..1` | 人-配偶 |

---

## 🍳 完整代码示例

```java
// 一对一 (1 to 1)
class 厨师 {
    private 厨师帽 hat;  // 正好1个
    
    public 厨师() {
        hat = new 厨师帽();  // 必须有
    }
}

// 一对多 (1 to many)
class 厨房 {
    private List<厨师> chefs = new ArrayList<>();  // 0..*
    
    void 雇佣(厨师 chef) {
        chefs.add(chef);
    }
}

// 多对多 (many to many)
class 厨师 {
    private List<菜谱> recipes = new ArrayList<>();  // 0..*
}

class 菜谱 {
    private List<厨师> chefs = new ArrayList<>();  // 0..*
}

// 固定数量
class 汽车 {
    private 轮子[] wheels = new 轮子[4];  // 正好4个
    
    public 汽车() {
        for (int i = 0; i < 4; i++) {
            wheels[i] = new 轮子();
        }
    }
}

// 可选的 (0..1)
class 人 {
    private 配偶 spouse;  // 可以是null
    
    void 结婚(配偶 partner) {
        if (spouse == null) {
            spouse = partner;
        }
    }
}

// 必须有 (1..*)
class 订单 {
    private List<菜品> dishes;
    
    boolean 是否有效() {
        return dishes != null && !dishes.isEmpty();  // 至少1个
    }
}
```

---

## 📝 总结表

| 写法 | 含义 | 代码实现 |
|------|------|----------|
| `1` | 正好1个 | `private X x;` (不能为null) |
| `0..1` | 0或1个 | `private X x;` (可以为null) |
| `*` 或 `0..*` | 任意个 | `private List<X> xs;` |
| `1..*` | 至少1个 | `private List<X> xs;` (不能为空) |
| `n` | 正好n个 | `private X[] xs = new X[n];` |

---

----

好的！我来详细讲解**类图中的关系**，这是最容易搞混的部分！

---

## 🎯 类图中的6种关系

用**做饭系统**来举例：

---

## 1️⃣ **依赖 (Dependencia)** `- - - - >`

### 关系：**"临时使用"**
```
一个类的方法里临时用到另一个类
用完就扔，不保存
```

### 做饭例子：
```
┌─────────┐           ┌─────────┐
│  厨师    │- - - - >│  菜谱    │
└─────────┘           └─────────┘
```

**代码：**
```java
class 厨师 {
    void 做菜() {
        菜谱 recipe = new 菜谱();  // 临时创建
        recipe.查看步骤();         // 用一下
        // 用完就不管了，不保存这个菜谱
    }
}
```

**特点：**
- ✅ 虚线箭头
- ✅ 最弱的关系
- ✅ 通常是**方法参数**或**局部变量**

---

## 2️⃣ **关联 (Asociación)** `────>`

### 关系：**"知道对方，长期持有"**
```
一个类有另一个类的引用（成员变量）
```

### 做饭例子：
```
┌─────────┐           ┌─────────┐
│  厨师    │────────>│  厨具    │
│         │          │         │
│- 厨具   │          └─────────┘
└─────────┘
```

**代码：**
```java
class 厨师 {
    private 厨具 myTools;  // 成员变量，长期持有
    
    void 做菜() {
        myTools.使用();
    }
}
```

**特点：**
- ✅ 实线箭头
- ✅ 有成员变量
- ✅ 箭头指向"被持有的类"

---

### 🔸 关联的特殊情况：

#### **A. 聚合 (Agregación)** `◇────>`
**关系：** "拥有，但可以分开"（has-a，弱拥有）

```
┌─────────┐           ┌─────────┐
│ 厨房     │◇────────>│ 厨师     │
└─────────┘           └─────────┘
厨房有厨师，但厨师可以离职
```

**代码：**
```java
class 厨房 {
    private List<厨师> 厨师们;  // 厨房有厨师
    
    void 添加厨师(厨师 chef) {
        厨师们.add(chef);  // 从外面传进来
    }
}

// 厨师可以独立存在
厨师 张三 = new 厨师("张三");
厨房 kitchen = new 厨房();
kitchen.添加厨师(张三);  // 张三可以离开厨房还活着
```

**特点：**
- ✅ 空心菱形
- ✅ 部分可以独立存在
- ✅ **对象从外面传入**

---

#### **B. 组合/复合 (Composición)** `◆────>`
**关系：** "拥有，不能分开"（强拥有，生死与共）

```
┌─────────┐           ┌─────────┐
│ 厨房     │◆────────>│ 厨具间   │
└─────────┘           └─────────┘
厨房没了，厨具间也没了
```

**代码：**
```java
class 厨房 {
    private 厨具间 storage;  // 厨具间
    
    public 厨房() {
        storage = new 厨具间();  // 在构造函数里创建
    }
    // 厨房销毁，厨具间也跟着销毁
}
```

**特点：**
- ✅ 实心菱形
- ✅ 部分不能独立存在
- ✅ **对象在内部创建**
- ✅ 生命周期绑定

---

## 3️⃣ **泛化/继承 (Generalización)** `◁────`

### 关系：**"是一种"（is-a）**
```
子类是父类的一种特殊类型
```

### 做饭例子：
```
        ┌─────────┐
        │  厨师    │ ← 父类
        └─────────┘
            △
            │
      ┌─────┴─────┐
      │           │
┌─────────┐ ┌─────────┐
│ 中餐厨师 │ │ 西餐厨师 │ ← 子类
└─────────┘ └─────────┘
```

**代码：**
```java
class 厨师 {
    void 做菜() { }
}

class 中餐厨师 extends 厨师 {
    void 炒菜() { }  // 特有方法
}

class 西餐厨师 extends 厨师 {
    void 烤牛排() { }
}
```

**特点：**
- ✅ 空心三角形箭头
- ✅ 箭头指向父类
- ✅ 表示继承关系

---

## 4️⃣ **实现 (Realización)** `◁ - - -`

### 关系：**"实现接口"**
```
类实现接口的方法
```

### 做饭例子：
```
┌─────────────┐
│<<interface>>│
│   可烹饪     │
│             │
│+ 做菜()     │
└─────────────┘
       △
       ┆ (虚线)
       │
┌─────────┐
│  厨师    │
│         │
│+ 做菜() │ ← 实现接口方法
└─────────┘
```

**代码：**
```java
interface 可烹饪 {
    void 做菜();
}

class 厨师 implements 可烹饪 {
    @Override
    public void 做菜() {
        // 具体实现
    }
}
```

**特点：**
- ✅ 虚线 + 空心三角
- ✅ 箭头指向接口
- ✅ 表示实现关系

---

## 📊 完整做饭系统类图

```
        ┌─────────────┐
        │<<interface>>│
        │   可烹饪     │
        └─────────────┘
               △
               ┆
               │
        ┌─────────┐
        │  厨师    │ ◁──────── 继承
        │- 姓名    │
        │- 工龄    │
        └─────────┘
            △
      ┌─────┴─────┐
      │           │
┌─────────┐ ┌─────────┐
│ 中餐厨师 │ │ 西餐厨师 │
└─────────┘ └─────────┘
      │           │
      │           │
      │关联       │关联
      ↓           ↓
┌─────────┐ ┌─────────┐
│  炒锅    │ │  烤箱    │
└─────────┘ └─────────┘


        ┌─────────┐
        │ 厨房     │
        └─────────┘
          ◆ │ ◇
          │ │ │
组合      │ │ │聚合
          │ │ │
    ┌─────┘ └─────┐
    ↓             ↓
┌─────────┐ ┌─────────┐
│ 厨具间   │ │  厨师    │
└─────────┘ └─────────┘
```

---

## 🎯 关系强度排序（从强到弱）

```
继承/实现 > 组合 > 聚合 > 关联 > 依赖
   │        │     │      │      │
   最强    强     中     弱    最弱
```

---

## 💡 记忆口诀

| 关系 | 符号 | 口诀 | 代码特征 |
|------|------|------|----------|
| **依赖** | `- - - ->` | 临时用用 | 方法参数/局部变量 |
| **关联** | `────>` | 长期持有 | 成员变量 |
| **聚合** | `◇───>` | 拥有但可分离 | 对象从外面传入 |
| **组合** | `◆───>` | 拥有且不可分离 | 对象内部创建 |
| **继承** | `◁───` | 是一种 | extends |
| **实现** | `◁- - -` | 实现接口 | implements |

---

## 🔍 如何判断用哪种关系？

### 问自己4个问题：

#### 1. **有没有 extends 或 implements？**
- 有 extends → **继承**
- 有 implements → **实现**

#### 2. **是否有成员变量？**
- 没有，只是方法参数 → **依赖**
- 有成员变量 → 继续看下一步

#### 3. **对象在哪创建？**
- 在内部创建（new） → **组合**
- 从外面传入 → **聚合** 或 **关联**

#### 4. **生命周期是否绑定？**
- 整体销毁，部分也销毁 → **组合**
- 部分可以独立存在 → **聚合**
- 只是普通引用 → **关联**

---

## 🍳 实战例子：餐厅系统

```java
// 1. 继承
class 员工 { }
class 厨师 extends 员工 { }  // ◁───

// 2. 实现
interface 可管理 { }
class 经理 implements 可管理 { }  // ◁- - -

// 3. 组合（强拥有）
class 餐厅 {
    private 厨房 kitchen = new 厨房();  // ◆───> 餐厅没了厨房也没了
}

// 4. 聚合（弱拥有）
class 厨房 {
    private List<厨师> chefs;  // ◇───> 厨师可以跳槽
    void 雇佣(厨师 chef) {
        chefs.add(chef);
    }
}

// 5. 关联
class 厨师 {
    private 炒锅 wok;  // ────> 厨师使用炒锅
}

// 6. 依赖
class 厨师 {
    void 做菜(菜谱 recipe) {  // - - - -> 临时看一眼菜谱
        recipe.查看();
    }
}
```

---

## 📝 练习：判断关系

看下面的代码，说出是什么关系：

```java
class 汽车 {
    private 发动机 engine = new 发动机();  // ？
    private 司机 driver;                   // ？
    
    void 加油(加油站 station) {            // ？
        station.加油();
    }
}

class 小汽车 extends 汽车 { }             // ？

interface 可驾驶 { }
class 汽车 implements 可驾驶 { }          // ？
```

**答案：**
1. `发动机` → **组合** ◆ (内部创建，生死与共)
2. `司机` → **聚合** ◇ (从外面传入，可以换司机)
3. `加油站` → **依赖** - - - (方法参数，临时使用)
4. `小汽车` → **继承** ◁─── (extends)
5. `可驾驶` → **实现** ◁- - - (implements)

---
