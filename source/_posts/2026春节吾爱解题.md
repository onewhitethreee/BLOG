---
uuid: 33d888f0-0d11-11f1-9daa-25e935019be3
title: 2026春节吾爱解题
date: 2026-02-18 22:31:36
tags:
---

又到了每年一度的解题环节了，我也是等了蛮久的，去年的这个时候都已经结束好久了，今年的春节太后面了，导致我以为都不会有了。

好吧，话不多说，我上一下自己的解题思路吧。纯小白


# Windows 初级题（二）

用Ida 打开后，`shift + F12` 可以看到如下关键词

![](https://img.164314.xyz/2026/02/dd0ccc26baf97f4155003bd0accbc179.png)

双击点进`[+] Correct flag: `，可以看到一个关键函数`sub_BCD130`，这个函数就是验证函数了。

![](https://img.164314.xyz/2026/02/3d83e8ef7266dd552ae0f08b1745f9ed.png)

在左侧的窗口中找到`start`函数，按`F5`反编译，发现调用了验证函数。

```
result = sub_BCD130(dword_BDF024);
```

![](https://img.164314.xyz/2026/02/0d4e6a8a97ee99329813165bcab13b4e.png)

双击点进，就看到了这个验证函数的反编译代码了，分析一下这个函数的流程：

1. 首先就打印了一个横幅，表示一些提示信息，告诉我们正确的flag长度是关键。

![](https://img.164314.xyz/2026/02/7d1b5add77f5fa787bb2f6972f1b32c6.png)

2. 接着就让用户输入密码了，然后读取用户输入的内容

![](https://img.164314.xyz/2026/02/c67ca2320e0922fcb528a582bb61f784.png)

3. 检查输入内容(sub_B01740) （第一个陷阱）

![](https://img.164314.xyz/2026/02/fca3ca0bafb6cbe1d479f89c9ac5e918.png)


这一步检查了输入的内容，其内容为

![](https://img.164314.xyz/2026/02/6f976663921beb34e33c4ba589774078.png)

中间有一个`v2 = byte_BD3019[v1++]`。这里是一个关键点，它是一个数组，保存着一个假Flag，也就是`52pojie_2026_HappyNewYear`，这是一个诱饵。通过Hex view可以看到这个诱饵。

函数是从`53`（ASCII '5'）开始的，然后逐字符读取`byte_BD3019`里的内容。

![](https://img.164314.xyz/2026/02/adbb957232e57bc820f8215e505acdb7.png)


4. 前16字符对比 （第二个陷阱）

![](https://img.164314.xyz/2026/02/546caa0a041d8541abf91995b15f9864.png)

这一步是对输入的前十六个字符进行对比，这里也有一个数组(byte_BD3032), 其内容为`52pojie2026Happy`. 如果此刻输入的内容前16为刚好匹配，就会进入` You're getting closer` 的分支，提示我们输入的内容已经很接近了。

![](https://img.164314.xyz/2026/02/771e533e43293d577abcb10f06191c14.png)


5. 长度验证

通过前面两个陷阱，我们知道了两个线索，现在让我们继续分析下一部分的代码

此处代码提示我们密码必须要求为31个字符。也就是说，正确的flag长度必须为31个字符。

![](https://img.164314.xyz/2026/02/60fdc33102bfec45dcb41569c25bba45.png)

6. XOR缓冲区比对

这是核心的验证部分了。程序调用了一个函数`sub_B016D0`来判断是否是正确的flag

![](https://img.164314.xyz/2026/02/fb8805cbf636b80002cbcb5befef5897.png)

双击进入这个函数，查看具体的实现

![](https://img.164314.xyz/2026/02/4b36be414f8f93cf78bc3c68b6f484bf.png)

在这里有一个非常关键的函数，也就是`sub_B01620`。这一步直接就告诉了我们正确的答案。

![](https://img.164314.xyz/2026/02/976a2f7b9fb33f380057a73a5742e57e.png)

通过这里的分析，可以知道每个字节进行了XOR 0x42的操作。交给AI来帮我们写一个简单的脚本来解密这个XOR缓冲区，得到正确的flag。

```python
import struct

buf = bytearray(32)
struct.pack_into('<I', buf,  0, 758280311)
struct.pack_into('<I', buf,  4, 1663511336)
struct.pack_into('<I', buf,  8, 1880974179)
struct.pack_into('<I', buf, 12, 494170226)
struct.pack_into('<I', buf, 16, 842146570)
struct.pack_into('<I', buf, 20, 657202491)
struct.pack_into('<I', buf, 24, 658185525)
struct.pack_into('<H', buf, 28, 12323)
buf[30] = 99

for i in range(31):
    buf[i] ^= 0x42

password = buf[:31].decode('ascii')
print(f"Password: {password}")
print(f"Length:   {len(password)}")

checksum = sum((i + 1) * c for i, c in enumerate(password.encode()))
print(f"Checksum: {checksum} (expected: 44709)")
```
输出：

```
Password: 52pojie!!!_2026_Happy_new_year!
Length:   31
Checksum: 44709 (expected: 44709)
```

输出的结果和我们前面知道的线索完全匹配，长度为31，前16字符也不完全匹配，校验和也正确。

哦对了，忘记说怎么知道这个checksum了。

7. Checksum验证

很简单，它直接写死了哈哈

![](https://img.164314.xyz/2026/02/de4f1e3550570160de94240bb61d507d.png)

![](https://img.164314.xyz/2026/02/393d76edb57bd392bbdfdaa8f4fa1998.png)

至于计算方法也很简单
```
checksum = Σ (i × password[i-1])   for i = 1, 2, ..., len
         = 1×p[0] + 2×p[1] + 3×p[2] + ... + 31×p[30]
```

8. 最终验证

从上面的分析结果，我们知道了正确的flag是`52pojie!!!_2026_Happy_new_year!`，我们可以直接输入这个flag来验证一下。

![](https://img.164314.xyz/2026/02/08f3b42257f5dbf4543bc9062822c27a.png)

至此，Windows初级（二）就算是完全的解出来了。